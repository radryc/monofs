// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v6.31.1
// source: api/proto/fetcher.proto

package proto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// SourceType identifies the data source backend.
type SourceType int32

const (
	SourceType_SOURCE_TYPE_UNKNOWN SourceType = 0
	SourceType_SOURCE_TYPE_GIT     SourceType = 1 // Git repository (GitHub, GitLab, etc.)
	SourceType_SOURCE_TYPE_GOMOD   SourceType = 2 // Go module proxy (proxy.golang.org)
	SourceType_SOURCE_TYPE_S3      SourceType = 3 // S3-compatible object storage
	SourceType_SOURCE_TYPE_HTTP    SourceType = 4 // Generic HTTP/HTTPS URL
	SourceType_SOURCE_TYPE_OCI     SourceType = 5 // OCI registry (container images)
)

// Enum value maps for SourceType.
var (
	SourceType_name = map[int32]string{
		0: "SOURCE_TYPE_UNKNOWN",
		1: "SOURCE_TYPE_GIT",
		2: "SOURCE_TYPE_GOMOD",
		3: "SOURCE_TYPE_S3",
		4: "SOURCE_TYPE_HTTP",
		5: "SOURCE_TYPE_OCI",
	}
	SourceType_value = map[string]int32{
		"SOURCE_TYPE_UNKNOWN": 0,
		"SOURCE_TYPE_GIT":     1,
		"SOURCE_TYPE_GOMOD":   2,
		"SOURCE_TYPE_S3":      3,
		"SOURCE_TYPE_HTTP":    4,
		"SOURCE_TYPE_OCI":     5,
	}
)

func (x SourceType) Enum() *SourceType {
	p := new(SourceType)
	*p = x
	return p
}

func (x SourceType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SourceType) Descriptor() protoreflect.EnumDescriptor {
	return file_api_proto_fetcher_proto_enumTypes[0].Descriptor()
}

func (SourceType) Type() protoreflect.EnumType {
	return &file_api_proto_fetcher_proto_enumTypes[0]
}

func (x SourceType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SourceType.Descriptor instead.
func (SourceType) EnumDescriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{0}
}

type AccessType int32

const (
	AccessType_ACCESS_TYPE_UNKNOWN AccessType = 0
	AccessType_ACCESS_TYPE_READ    AccessType = 1 // File content read
	AccessType_ACCESS_TYPE_READDIR AccessType = 2 // Directory listing
	AccessType_ACCESS_TYPE_LOOKUP  AccessType = 3 // File/dir existence check
	AccessType_ACCESS_TYPE_GETATTR AccessType = 4 // Metadata retrieval
)

// Enum value maps for AccessType.
var (
	AccessType_name = map[int32]string{
		0: "ACCESS_TYPE_UNKNOWN",
		1: "ACCESS_TYPE_READ",
		2: "ACCESS_TYPE_READDIR",
		3: "ACCESS_TYPE_LOOKUP",
		4: "ACCESS_TYPE_GETATTR",
	}
	AccessType_value = map[string]int32{
		"ACCESS_TYPE_UNKNOWN": 0,
		"ACCESS_TYPE_READ":    1,
		"ACCESS_TYPE_READDIR": 2,
		"ACCESS_TYPE_LOOKUP":  3,
		"ACCESS_TYPE_GETATTR": 4,
	}
)

func (x AccessType) Enum() *AccessType {
	p := new(AccessType)
	*p = x
	return p
}

func (x AccessType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AccessType) Descriptor() protoreflect.EnumDescriptor {
	return file_api_proto_fetcher_proto_enumTypes[1].Descriptor()
}

func (AccessType) Type() protoreflect.EnumType {
	return &file_api_proto_fetcher_proto_enumTypes[1]
}

func (x AccessType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AccessType.Descriptor instead.
func (AccessType) EnumDescriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{1}
}

type FetchBlobRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Content identifier (interpretation depends on source_type):
	// - GIT: blob SHA hash
	// - GOMOD: module@version/path
	// - S3: bucket/key
	// - HTTP: full URL
	ContentId string `protobuf:"bytes,1,opt,name=content_id,json=contentId,proto3" json:"content_id,omitempty"`
	// Source type determines which backend handles the request.
	SourceType SourceType `protobuf:"varint,2,opt,name=source_type,json=sourceType,proto3,enum=monofs.SourceType" json:"source_type,omitempty"`
	// Source-specific configuration:
	// GIT: repo_url, branch, display_path
	// GOMOD: module_path, version
	// S3: endpoint, bucket, region
	// HTTP: (none, content_id is the URL)
	SourceConfig map[string]string `protobuf:"bytes,3,rep,name=source_config,json=sourceConfig,proto3" json:"source_config,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Request metadata for tracing/metrics.
	RequestId     string `protobuf:"bytes,10,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	StorageNodeId string `protobuf:"bytes,11,opt,name=storage_node_id,json=storageNodeId,proto3" json:"storage_node_id,omitempty"`
	StorageId     string `protobuf:"bytes,12,opt,name=storage_id,json=storageId,proto3" json:"storage_id,omitempty"` // Repository storage ID (for affinity routing)
	// Priority: 0 = highest (sync read), 10 = lowest (speculative prefetch)
	Priority      int32 `protobuf:"varint,13,opt,name=priority,proto3" json:"priority,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FetchBlobRequest) Reset() {
	*x = FetchBlobRequest{}
	mi := &file_api_proto_fetcher_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FetchBlobRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetchBlobRequest) ProtoMessage() {}

func (x *FetchBlobRequest) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_fetcher_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetchBlobRequest.ProtoReflect.Descriptor instead.
func (*FetchBlobRequest) Descriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{0}
}

func (x *FetchBlobRequest) GetContentId() string {
	if x != nil {
		return x.ContentId
	}
	return ""
}

func (x *FetchBlobRequest) GetSourceType() SourceType {
	if x != nil {
		return x.SourceType
	}
	return SourceType_SOURCE_TYPE_UNKNOWN
}

func (x *FetchBlobRequest) GetSourceConfig() map[string]string {
	if x != nil {
		return x.SourceConfig
	}
	return nil
}

func (x *FetchBlobRequest) GetRequestId() string {
	if x != nil {
		return x.RequestId
	}
	return ""
}

func (x *FetchBlobRequest) GetStorageNodeId() string {
	if x != nil {
		return x.StorageNodeId
	}
	return ""
}

func (x *FetchBlobRequest) GetStorageId() string {
	if x != nil {
		return x.StorageId
	}
	return ""
}

func (x *FetchBlobRequest) GetPriority() int32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

type FetchBlobBatchRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Blobs []*FetchBlobRequest    `protobuf:"bytes,1,rep,name=blobs,proto3" json:"blobs,omitempty"`
	// Max concurrent fetches (0 = use server default).
	Concurrency int32 `protobuf:"varint,2,opt,name=concurrency,proto3" json:"concurrency,omitempty"`
	// Stop on first error vs. continue and report all errors.
	FailFast      bool `protobuf:"varint,3,opt,name=fail_fast,json=failFast,proto3" json:"fail_fast,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FetchBlobBatchRequest) Reset() {
	*x = FetchBlobBatchRequest{}
	mi := &file_api_proto_fetcher_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FetchBlobBatchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetchBlobBatchRequest) ProtoMessage() {}

func (x *FetchBlobBatchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_fetcher_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetchBlobBatchRequest.ProtoReflect.Descriptor instead.
func (*FetchBlobBatchRequest) Descriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{1}
}

func (x *FetchBlobBatchRequest) GetBlobs() []*FetchBlobRequest {
	if x != nil {
		return x.Blobs
	}
	return nil
}

func (x *FetchBlobBatchRequest) GetConcurrency() int32 {
	if x != nil {
		return x.Concurrency
	}
	return 0
}

func (x *FetchBlobBatchRequest) GetFailFast() bool {
	if x != nil {
		return x.FailFast
	}
	return false
}

type FetchBlobBatchResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Content ID from the request.
	ContentId string `protobuf:"bytes,1,opt,name=content_id,json=contentId,proto3" json:"content_id,omitempty"`
	// Blob data (for small blobs) or empty if streaming separately.
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	// Size in bytes.
	Size int64 `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
	// True if this blob was served from fetcher's local cache.
	FromCache bool `protobuf:"varint,4,opt,name=from_cache,json=fromCache,proto3" json:"from_cache,omitempty"`
	// Fetch latency in milliseconds (0 if from cache).
	FetchLatencyMs int64 `protobuf:"varint,5,opt,name=fetch_latency_ms,json=fetchLatencyMs,proto3" json:"fetch_latency_ms,omitempty"`
	// Error message (empty on success).
	Error string `protobuf:"bytes,6,opt,name=error,proto3" json:"error,omitempty"`
	// Indicates this is the last response in the batch.
	BatchComplete bool `protobuf:"varint,10,opt,name=batch_complete,json=batchComplete,proto3" json:"batch_complete,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FetchBlobBatchResponse) Reset() {
	*x = FetchBlobBatchResponse{}
	mi := &file_api_proto_fetcher_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FetchBlobBatchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetchBlobBatchResponse) ProtoMessage() {}

func (x *FetchBlobBatchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_fetcher_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetchBlobBatchResponse.ProtoReflect.Descriptor instead.
func (*FetchBlobBatchResponse) Descriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{2}
}

func (x *FetchBlobBatchResponse) GetContentId() string {
	if x != nil {
		return x.ContentId
	}
	return ""
}

func (x *FetchBlobBatchResponse) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *FetchBlobBatchResponse) GetSize() int64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *FetchBlobBatchResponse) GetFromCache() bool {
	if x != nil {
		return x.FromCache
	}
	return false
}

func (x *FetchBlobBatchResponse) GetFetchLatencyMs() int64 {
	if x != nil {
		return x.FetchLatencyMs
	}
	return 0
}

func (x *FetchBlobBatchResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *FetchBlobBatchResponse) GetBatchComplete() bool {
	if x != nil {
		return x.BatchComplete
	}
	return false
}

type PrefetchRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Blobs to prefetch (same format as FetchBlobRequest).
	Blobs []*FetchBlobRequest `protobuf:"bytes,1,rep,name=blobs,proto3" json:"blobs,omitempty"`
	// Callback URL for completion notification (optional).
	// If set, fetcher will POST to this URL when prefetch completes.
	CallbackUrl string `protobuf:"bytes,2,opt,name=callback_url,json=callbackUrl,proto3" json:"callback_url,omitempty"`
	// TTL for prefetched blobs in fetcher cache (seconds).
	// 0 = use server default.
	CacheTtlSeconds int32 `protobuf:"varint,3,opt,name=cache_ttl_seconds,json=cacheTtlSeconds,proto3" json:"cache_ttl_seconds,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PrefetchRequest) Reset() {
	*x = PrefetchRequest{}
	mi := &file_api_proto_fetcher_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrefetchRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrefetchRequest) ProtoMessage() {}

func (x *PrefetchRequest) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_fetcher_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrefetchRequest.ProtoReflect.Descriptor instead.
func (*PrefetchRequest) Descriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{3}
}

func (x *PrefetchRequest) GetBlobs() []*FetchBlobRequest {
	if x != nil {
		return x.Blobs
	}
	return nil
}

func (x *PrefetchRequest) GetCallbackUrl() string {
	if x != nil {
		return x.CallbackUrl
	}
	return ""
}

func (x *PrefetchRequest) GetCacheTtlSeconds() int32 {
	if x != nil {
		return x.CacheTtlSeconds
	}
	return 0
}

type PrefetchResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Job ID for tracking (can be used with CheckCache).
	JobId string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	// Number of blobs accepted for prefetch.
	Accepted int32 `protobuf:"varint,2,opt,name=accepted,proto3" json:"accepted,omitempty"`
	// Number of blobs already cached (will skip fetch).
	AlreadyCached int32 `protobuf:"varint,3,opt,name=already_cached,json=alreadyCached,proto3" json:"already_cached,omitempty"`
	// Number of blobs rejected (invalid request, etc.).
	Rejected      int32 `protobuf:"varint,4,opt,name=rejected,proto3" json:"rejected,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PrefetchResponse) Reset() {
	*x = PrefetchResponse{}
	mi := &file_api_proto_fetcher_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrefetchResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrefetchResponse) ProtoMessage() {}

func (x *PrefetchResponse) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_fetcher_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrefetchResponse.ProtoReflect.Descriptor instead.
func (*PrefetchResponse) Descriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{4}
}

func (x *PrefetchResponse) GetJobId() string {
	if x != nil {
		return x.JobId
	}
	return ""
}

func (x *PrefetchResponse) GetAccepted() int32 {
	if x != nil {
		return x.Accepted
	}
	return 0
}

func (x *PrefetchResponse) GetAlreadyCached() int32 {
	if x != nil {
		return x.AlreadyCached
	}
	return 0
}

func (x *PrefetchResponse) GetRejected() int32 {
	if x != nil {
		return x.Rejected
	}
	return 0
}

type CheckCacheRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Content IDs to check.
	ContentIds []string `protobuf:"bytes,1,rep,name=content_ids,json=contentIds,proto3" json:"content_ids,omitempty"`
	// Source type (needed to identify cache keys).
	SourceType    SourceType `protobuf:"varint,2,opt,name=source_type,json=sourceType,proto3,enum=monofs.SourceType" json:"source_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckCacheRequest) Reset() {
	*x = CheckCacheRequest{}
	mi := &file_api_proto_fetcher_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckCacheRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckCacheRequest) ProtoMessage() {}

func (x *CheckCacheRequest) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_fetcher_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckCacheRequest.ProtoReflect.Descriptor instead.
func (*CheckCacheRequest) Descriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{5}
}

func (x *CheckCacheRequest) GetContentIds() []string {
	if x != nil {
		return x.ContentIds
	}
	return nil
}

func (x *CheckCacheRequest) GetSourceType() SourceType {
	if x != nil {
		return x.SourceType
	}
	return SourceType_SOURCE_TYPE_UNKNOWN
}

type CheckCacheResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Map of content_id -> cached (true/false).
	Cached map[string]bool `protobuf:"bytes,1,rep,name=cached,proto3" json:"cached,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// Map of content_id -> size in bytes (only for cached items).
	Sizes         map[string]int64 `protobuf:"bytes,2,rep,name=sizes,proto3" json:"sizes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckCacheResponse) Reset() {
	*x = CheckCacheResponse{}
	mi := &file_api_proto_fetcher_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckCacheResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckCacheResponse) ProtoMessage() {}

func (x *CheckCacheResponse) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_fetcher_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckCacheResponse.ProtoReflect.Descriptor instead.
func (*CheckCacheResponse) Descriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{6}
}

func (x *CheckCacheResponse) GetCached() map[string]bool {
	if x != nil {
		return x.Cached
	}
	return nil
}

func (x *CheckCacheResponse) GetSizes() map[string]int64 {
	if x != nil {
		return x.Sizes
	}
	return nil
}

type FetcherStatsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Include detailed per-source stats.
	IncludeSourceStats bool `protobuf:"varint,1,opt,name=include_source_stats,json=includeSourceStats,proto3" json:"include_source_stats,omitempty"`
	// Include cache contents summary.
	IncludeCacheStats bool `protobuf:"varint,2,opt,name=include_cache_stats,json=includeCacheStats,proto3" json:"include_cache_stats,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *FetcherStatsRequest) Reset() {
	*x = FetcherStatsRequest{}
	mi := &file_api_proto_fetcher_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FetcherStatsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetcherStatsRequest) ProtoMessage() {}

func (x *FetcherStatsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_fetcher_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetcherStatsRequest.ProtoReflect.Descriptor instead.
func (*FetcherStatsRequest) Descriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{7}
}

func (x *FetcherStatsRequest) GetIncludeSourceStats() bool {
	if x != nil {
		return x.IncludeSourceStats
	}
	return false
}

func (x *FetcherStatsRequest) GetIncludeCacheStats() bool {
	if x != nil {
		return x.IncludeCacheStats
	}
	return false
}

type FetcherStatsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Fetcher instance ID.
	FetcherId string `protobuf:"bytes,1,opt,name=fetcher_id,json=fetcherId,proto3" json:"fetcher_id,omitempty"`
	// Uptime in seconds.
	UptimeSeconds int64 `protobuf:"varint,2,opt,name=uptime_seconds,json=uptimeSeconds,proto3" json:"uptime_seconds,omitempty"`
	// Total requests served.
	TotalRequests int64 `protobuf:"varint,3,opt,name=total_requests,json=totalRequests,proto3" json:"total_requests,omitempty"`
	// Cache statistics.
	CacheHits      int64   `protobuf:"varint,4,opt,name=cache_hits,json=cacheHits,proto3" json:"cache_hits,omitempty"`
	CacheMisses    int64   `protobuf:"varint,5,opt,name=cache_misses,json=cacheMisses,proto3" json:"cache_misses,omitempty"`
	CacheHitRate   float64 `protobuf:"fixed64,6,opt,name=cache_hit_rate,json=cacheHitRate,proto3" json:"cache_hit_rate,omitempty"`
	CacheSizeBytes int64   `protobuf:"varint,7,opt,name=cache_size_bytes,json=cacheSizeBytes,proto3" json:"cache_size_bytes,omitempty"`
	CacheEntries   int64   `protobuf:"varint,8,opt,name=cache_entries,json=cacheEntries,proto3" json:"cache_entries,omitempty"`
	// Active operations.
	ActiveFetches    int64 `protobuf:"varint,9,opt,name=active_fetches,json=activeFetches,proto3" json:"active_fetches,omitempty"`
	QueuedPrefetches int64 `protobuf:"varint,10,opt,name=queued_prefetches,json=queuedPrefetches,proto3" json:"queued_prefetches,omitempty"`
	// Per-source statistics.
	SourceStats map[string]*SourceStats `protobuf:"bytes,11,rep,name=source_stats,json=sourceStats,proto3" json:"source_stats,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Bytes transferred.
	BytesFetched  int64 `protobuf:"varint,12,opt,name=bytes_fetched,json=bytesFetched,proto3" json:"bytes_fetched,omitempty"`
	BytesServed   int64 `protobuf:"varint,13,opt,name=bytes_served,json=bytesServed,proto3" json:"bytes_served,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FetcherStatsResponse) Reset() {
	*x = FetcherStatsResponse{}
	mi := &file_api_proto_fetcher_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FetcherStatsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetcherStatsResponse) ProtoMessage() {}

func (x *FetcherStatsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_fetcher_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetcherStatsResponse.ProtoReflect.Descriptor instead.
func (*FetcherStatsResponse) Descriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{8}
}

func (x *FetcherStatsResponse) GetFetcherId() string {
	if x != nil {
		return x.FetcherId
	}
	return ""
}

func (x *FetcherStatsResponse) GetUptimeSeconds() int64 {
	if x != nil {
		return x.UptimeSeconds
	}
	return 0
}

func (x *FetcherStatsResponse) GetTotalRequests() int64 {
	if x != nil {
		return x.TotalRequests
	}
	return 0
}

func (x *FetcherStatsResponse) GetCacheHits() int64 {
	if x != nil {
		return x.CacheHits
	}
	return 0
}

func (x *FetcherStatsResponse) GetCacheMisses() int64 {
	if x != nil {
		return x.CacheMisses
	}
	return 0
}

func (x *FetcherStatsResponse) GetCacheHitRate() float64 {
	if x != nil {
		return x.CacheHitRate
	}
	return 0
}

func (x *FetcherStatsResponse) GetCacheSizeBytes() int64 {
	if x != nil {
		return x.CacheSizeBytes
	}
	return 0
}

func (x *FetcherStatsResponse) GetCacheEntries() int64 {
	if x != nil {
		return x.CacheEntries
	}
	return 0
}

func (x *FetcherStatsResponse) GetActiveFetches() int64 {
	if x != nil {
		return x.ActiveFetches
	}
	return 0
}

func (x *FetcherStatsResponse) GetQueuedPrefetches() int64 {
	if x != nil {
		return x.QueuedPrefetches
	}
	return 0
}

func (x *FetcherStatsResponse) GetSourceStats() map[string]*SourceStats {
	if x != nil {
		return x.SourceStats
	}
	return nil
}

func (x *FetcherStatsResponse) GetBytesFetched() int64 {
	if x != nil {
		return x.BytesFetched
	}
	return 0
}

func (x *FetcherStatsResponse) GetBytesServed() int64 {
	if x != nil {
		return x.BytesServed
	}
	return 0
}

type SourceStats struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Requests      int64                  `protobuf:"varint,1,opt,name=requests,proto3" json:"requests,omitempty"`
	Errors        int64                  `protobuf:"varint,2,opt,name=errors,proto3" json:"errors,omitempty"`
	BytesFetched  int64                  `protobuf:"varint,3,opt,name=bytes_fetched,json=bytesFetched,proto3" json:"bytes_fetched,omitempty"`
	AvgLatencyMs  float64                `protobuf:"fixed64,4,opt,name=avg_latency_ms,json=avgLatencyMs,proto3" json:"avg_latency_ms,omitempty"`
	CachedItems   int64                  `protobuf:"varint,5,opt,name=cached_items,json=cachedItems,proto3" json:"cached_items,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SourceStats) Reset() {
	*x = SourceStats{}
	mi := &file_api_proto_fetcher_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SourceStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SourceStats) ProtoMessage() {}

func (x *SourceStats) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_fetcher_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SourceStats.ProtoReflect.Descriptor instead.
func (*SourceStats) Descriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{9}
}

func (x *SourceStats) GetRequests() int64 {
	if x != nil {
		return x.Requests
	}
	return 0
}

func (x *SourceStats) GetErrors() int64 {
	if x != nil {
		return x.Errors
	}
	return 0
}

func (x *SourceStats) GetBytesFetched() int64 {
	if x != nil {
		return x.BytesFetched
	}
	return 0
}

func (x *SourceStats) GetAvgLatencyMs() float64 {
	if x != nil {
		return x.AvgLatencyMs
	}
	return 0
}

func (x *SourceStats) GetCachedItems() int64 {
	if x != nil {
		return x.CachedItems
	}
	return 0
}

// Access event reported by storage nodes for prediction training.
type AccessEvent struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ClientId      string                 `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`                               // FUSE client identifier
	StorageId     string                 `protobuf:"bytes,2,opt,name=storage_id,json=storageId,proto3" json:"storage_id,omitempty"`                            // Repository storage ID
	FilePath      string                 `protobuf:"bytes,3,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`                               // Path within repository
	Timestamp     int64                  `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`                                            // Unix timestamp (nanoseconds)
	AccessType    AccessType             `protobuf:"varint,5,opt,name=access_type,json=accessType,proto3,enum=monofs.AccessType" json:"access_type,omitempty"` // Type of access
	SessionId     string                 `protobuf:"bytes,6,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`                            // Groups related accesses
	NodeId        string                 `protobuf:"bytes,7,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`                                     // Storage node that served the request
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AccessEvent) Reset() {
	*x = AccessEvent{}
	mi := &file_api_proto_fetcher_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AccessEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccessEvent) ProtoMessage() {}

func (x *AccessEvent) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_fetcher_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccessEvent.ProtoReflect.Descriptor instead.
func (*AccessEvent) Descriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{10}
}

func (x *AccessEvent) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *AccessEvent) GetStorageId() string {
	if x != nil {
		return x.StorageId
	}
	return ""
}

func (x *AccessEvent) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *AccessEvent) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *AccessEvent) GetAccessType() AccessType {
	if x != nil {
		return x.AccessType
	}
	return AccessType_ACCESS_TYPE_UNKNOWN
}

func (x *AccessEvent) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *AccessEvent) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

// Storage nodes report access events to router for global prediction.
type ReportAccessRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Events        []*AccessEvent         `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReportAccessRequest) Reset() {
	*x = ReportAccessRequest{}
	mi := &file_api_proto_fetcher_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReportAccessRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReportAccessRequest) ProtoMessage() {}

func (x *ReportAccessRequest) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_fetcher_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReportAccessRequest.ProtoReflect.Descriptor instead.
func (*ReportAccessRequest) Descriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{11}
}

func (x *ReportAccessRequest) GetEvents() []*AccessEvent {
	if x != nil {
		return x.Events
	}
	return nil
}

type ReportAccessResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Accepted      int32                  `protobuf:"varint,1,opt,name=accepted,proto3" json:"accepted,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReportAccessResponse) Reset() {
	*x = ReportAccessResponse{}
	mi := &file_api_proto_fetcher_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReportAccessResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReportAccessResponse) ProtoMessage() {}

func (x *ReportAccessResponse) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_fetcher_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReportAccessResponse.ProtoReflect.Descriptor instead.
func (*ReportAccessResponse) Descriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{12}
}

func (x *ReportAccessResponse) GetAccepted() int32 {
	if x != nil {
		return x.Accepted
	}
	return 0
}

// Request predictions for a file (what should be prefetched next).
type GetPredictionsRequest struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	StorageId      string                 `protobuf:"bytes,1,opt,name=storage_id,json=storageId,proto3" json:"storage_id,omitempty"`
	FilePath       string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	ClientId       string                 `protobuf:"bytes,3,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	MaxResults     int32                  `protobuf:"varint,4,opt,name=max_results,json=maxResults,proto3" json:"max_results,omitempty"`
	MinProbability float32                `protobuf:"fixed32,5,opt,name=min_probability,json=minProbability,proto3" json:"min_probability,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *GetPredictionsRequest) Reset() {
	*x = GetPredictionsRequest{}
	mi := &file_api_proto_fetcher_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPredictionsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPredictionsRequest) ProtoMessage() {}

func (x *GetPredictionsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_fetcher_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPredictionsRequest.ProtoReflect.Descriptor instead.
func (*GetPredictionsRequest) Descriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{13}
}

func (x *GetPredictionsRequest) GetStorageId() string {
	if x != nil {
		return x.StorageId
	}
	return ""
}

func (x *GetPredictionsRequest) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *GetPredictionsRequest) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *GetPredictionsRequest) GetMaxResults() int32 {
	if x != nil {
		return x.MaxResults
	}
	return 0
}

func (x *GetPredictionsRequest) GetMinProbability() float32 {
	if x != nil {
		return x.MinProbability
	}
	return 0
}

type GetPredictionsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Predictions   []*PredictedFile       `protobuf:"bytes,1,rep,name=predictions,proto3" json:"predictions,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetPredictionsResponse) Reset() {
	*x = GetPredictionsResponse{}
	mi := &file_api_proto_fetcher_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPredictionsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPredictionsResponse) ProtoMessage() {}

func (x *GetPredictionsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_fetcher_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPredictionsResponse.ProtoReflect.Descriptor instead.
func (*GetPredictionsResponse) Descriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{14}
}

func (x *GetPredictionsResponse) GetPredictions() []*PredictedFile {
	if x != nil {
		return x.Predictions
	}
	return nil
}

type PredictedFile struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	StorageId     string                 `protobuf:"bytes,1,opt,name=storage_id,json=storageId,proto3" json:"storage_id,omitempty"`
	FilePath      string                 `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	Probability   float32                `protobuf:"fixed32,3,opt,name=probability,proto3" json:"probability,omitempty"`
	Source        string                 `protobuf:"bytes,4,opt,name=source,proto3" json:"source,omitempty"`                                                   // "markov", "cluster", "structural", "temporal"
	ContentId     string                 `protobuf:"bytes,5,opt,name=content_id,json=contentId,proto3" json:"content_id,omitempty"`                            // Blob hash for fetching
	SourceType    SourceType             `protobuf:"varint,6,opt,name=source_type,json=sourceType,proto3,enum=monofs.SourceType" json:"source_type,omitempty"` // How to fetch
	SourceConfig  map[string]string      `protobuf:"bytes,7,rep,name=source_config,json=sourceConfig,proto3" json:"source_config,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PredictedFile) Reset() {
	*x = PredictedFile{}
	mi := &file_api_proto_fetcher_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PredictedFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PredictedFile) ProtoMessage() {}

func (x *PredictedFile) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_fetcher_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PredictedFile.ProtoReflect.Descriptor instead.
func (*PredictedFile) Descriptor() ([]byte, []int) {
	return file_api_proto_fetcher_proto_rawDescGZIP(), []int{15}
}

func (x *PredictedFile) GetStorageId() string {
	if x != nil {
		return x.StorageId
	}
	return ""
}

func (x *PredictedFile) GetFilePath() string {
	if x != nil {
		return x.FilePath
	}
	return ""
}

func (x *PredictedFile) GetProbability() float32 {
	if x != nil {
		return x.Probability
	}
	return 0
}

func (x *PredictedFile) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *PredictedFile) GetContentId() string {
	if x != nil {
		return x.ContentId
	}
	return ""
}

func (x *PredictedFile) GetSourceType() SourceType {
	if x != nil {
		return x.SourceType
	}
	return SourceType_SOURCE_TYPE_UNKNOWN
}

func (x *PredictedFile) GetSourceConfig() map[string]string {
	if x != nil {
		return x.SourceConfig
	}
	return nil
}

var File_api_proto_fetcher_proto protoreflect.FileDescriptor

const file_api_proto_fetcher_proto_rawDesc = "" +
	"\n" +
	"\x17api/proto/fetcher.proto\x12\x06monofs\x1a\x16api/proto/monofs.proto\"\xfa\x02\n" +
	"\x10FetchBlobRequest\x12\x1d\n" +
	"\n" +
	"content_id\x18\x01 \x01(\tR\tcontentId\x123\n" +
	"\vsource_type\x18\x02 \x01(\x0e2\x12.monofs.SourceTypeR\n" +
	"sourceType\x12O\n" +
	"\rsource_config\x18\x03 \x03(\v2*.monofs.FetchBlobRequest.SourceConfigEntryR\fsourceConfig\x12\x1d\n" +
	"\n" +
	"request_id\x18\n" +
	" \x01(\tR\trequestId\x12&\n" +
	"\x0fstorage_node_id\x18\v \x01(\tR\rstorageNodeId\x12\x1d\n" +
	"\n" +
	"storage_id\x18\f \x01(\tR\tstorageId\x12\x1a\n" +
	"\bpriority\x18\r \x01(\x05R\bpriority\x1a?\n" +
	"\x11SourceConfigEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x86\x01\n" +
	"\x15FetchBlobBatchRequest\x12.\n" +
	"\x05blobs\x18\x01 \x03(\v2\x18.monofs.FetchBlobRequestR\x05blobs\x12 \n" +
	"\vconcurrency\x18\x02 \x01(\x05R\vconcurrency\x12\x1b\n" +
	"\tfail_fast\x18\x03 \x01(\bR\bfailFast\"\xe5\x01\n" +
	"\x16FetchBlobBatchResponse\x12\x1d\n" +
	"\n" +
	"content_id\x18\x01 \x01(\tR\tcontentId\x12\x12\n" +
	"\x04data\x18\x02 \x01(\fR\x04data\x12\x12\n" +
	"\x04size\x18\x03 \x01(\x03R\x04size\x12\x1d\n" +
	"\n" +
	"from_cache\x18\x04 \x01(\bR\tfromCache\x12(\n" +
	"\x10fetch_latency_ms\x18\x05 \x01(\x03R\x0efetchLatencyMs\x12\x14\n" +
	"\x05error\x18\x06 \x01(\tR\x05error\x12%\n" +
	"\x0ebatch_complete\x18\n" +
	" \x01(\bR\rbatchComplete\"\x90\x01\n" +
	"\x0fPrefetchRequest\x12.\n" +
	"\x05blobs\x18\x01 \x03(\v2\x18.monofs.FetchBlobRequestR\x05blobs\x12!\n" +
	"\fcallback_url\x18\x02 \x01(\tR\vcallbackUrl\x12*\n" +
	"\x11cache_ttl_seconds\x18\x03 \x01(\x05R\x0fcacheTtlSeconds\"\x88\x01\n" +
	"\x10PrefetchResponse\x12\x15\n" +
	"\x06job_id\x18\x01 \x01(\tR\x05jobId\x12\x1a\n" +
	"\baccepted\x18\x02 \x01(\x05R\baccepted\x12%\n" +
	"\x0ealready_cached\x18\x03 \x01(\x05R\ralreadyCached\x12\x1a\n" +
	"\brejected\x18\x04 \x01(\x05R\brejected\"i\n" +
	"\x11CheckCacheRequest\x12\x1f\n" +
	"\vcontent_ids\x18\x01 \x03(\tR\n" +
	"contentIds\x123\n" +
	"\vsource_type\x18\x02 \x01(\x0e2\x12.monofs.SourceTypeR\n" +
	"sourceType\"\x86\x02\n" +
	"\x12CheckCacheResponse\x12>\n" +
	"\x06cached\x18\x01 \x03(\v2&.monofs.CheckCacheResponse.CachedEntryR\x06cached\x12;\n" +
	"\x05sizes\x18\x02 \x03(\v2%.monofs.CheckCacheResponse.SizesEntryR\x05sizes\x1a9\n" +
	"\vCachedEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\bR\x05value:\x028\x01\x1a8\n" +
	"\n" +
	"SizesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\x03R\x05value:\x028\x01\"w\n" +
	"\x13FetcherStatsRequest\x120\n" +
	"\x14include_source_stats\x18\x01 \x01(\bR\x12includeSourceStats\x12.\n" +
	"\x13include_cache_stats\x18\x02 \x01(\bR\x11includeCacheStats\"\xfd\x04\n" +
	"\x14FetcherStatsResponse\x12\x1d\n" +
	"\n" +
	"fetcher_id\x18\x01 \x01(\tR\tfetcherId\x12%\n" +
	"\x0euptime_seconds\x18\x02 \x01(\x03R\ruptimeSeconds\x12%\n" +
	"\x0etotal_requests\x18\x03 \x01(\x03R\rtotalRequests\x12\x1d\n" +
	"\n" +
	"cache_hits\x18\x04 \x01(\x03R\tcacheHits\x12!\n" +
	"\fcache_misses\x18\x05 \x01(\x03R\vcacheMisses\x12$\n" +
	"\x0ecache_hit_rate\x18\x06 \x01(\x01R\fcacheHitRate\x12(\n" +
	"\x10cache_size_bytes\x18\a \x01(\x03R\x0ecacheSizeBytes\x12#\n" +
	"\rcache_entries\x18\b \x01(\x03R\fcacheEntries\x12%\n" +
	"\x0eactive_fetches\x18\t \x01(\x03R\ractiveFetches\x12+\n" +
	"\x11queued_prefetches\x18\n" +
	" \x01(\x03R\x10queuedPrefetches\x12P\n" +
	"\fsource_stats\x18\v \x03(\v2-.monofs.FetcherStatsResponse.SourceStatsEntryR\vsourceStats\x12#\n" +
	"\rbytes_fetched\x18\f \x01(\x03R\fbytesFetched\x12!\n" +
	"\fbytes_served\x18\r \x01(\x03R\vbytesServed\x1aS\n" +
	"\x10SourceStatsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12)\n" +
	"\x05value\x18\x02 \x01(\v2\x13.monofs.SourceStatsR\x05value:\x028\x01\"\xaf\x01\n" +
	"\vSourceStats\x12\x1a\n" +
	"\brequests\x18\x01 \x01(\x03R\brequests\x12\x16\n" +
	"\x06errors\x18\x02 \x01(\x03R\x06errors\x12#\n" +
	"\rbytes_fetched\x18\x03 \x01(\x03R\fbytesFetched\x12$\n" +
	"\x0eavg_latency_ms\x18\x04 \x01(\x01R\favgLatencyMs\x12!\n" +
	"\fcached_items\x18\x05 \x01(\x03R\vcachedItems\"\xf1\x01\n" +
	"\vAccessEvent\x12\x1b\n" +
	"\tclient_id\x18\x01 \x01(\tR\bclientId\x12\x1d\n" +
	"\n" +
	"storage_id\x18\x02 \x01(\tR\tstorageId\x12\x1b\n" +
	"\tfile_path\x18\x03 \x01(\tR\bfilePath\x12\x1c\n" +
	"\ttimestamp\x18\x04 \x01(\x03R\ttimestamp\x123\n" +
	"\vaccess_type\x18\x05 \x01(\x0e2\x12.monofs.AccessTypeR\n" +
	"accessType\x12\x1d\n" +
	"\n" +
	"session_id\x18\x06 \x01(\tR\tsessionId\x12\x17\n" +
	"\anode_id\x18\a \x01(\tR\x06nodeId\"B\n" +
	"\x13ReportAccessRequest\x12+\n" +
	"\x06events\x18\x01 \x03(\v2\x13.monofs.AccessEventR\x06events\"2\n" +
	"\x14ReportAccessResponse\x12\x1a\n" +
	"\baccepted\x18\x01 \x01(\x05R\baccepted\"\xba\x01\n" +
	"\x15GetPredictionsRequest\x12\x1d\n" +
	"\n" +
	"storage_id\x18\x01 \x01(\tR\tstorageId\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\x12\x1b\n" +
	"\tclient_id\x18\x03 \x01(\tR\bclientId\x12\x1f\n" +
	"\vmax_results\x18\x04 \x01(\x05R\n" +
	"maxResults\x12'\n" +
	"\x0fmin_probability\x18\x05 \x01(\x02R\x0eminProbability\"Q\n" +
	"\x16GetPredictionsResponse\x127\n" +
	"\vpredictions\x18\x01 \x03(\v2\x15.monofs.PredictedFileR\vpredictions\"\xe8\x02\n" +
	"\rPredictedFile\x12\x1d\n" +
	"\n" +
	"storage_id\x18\x01 \x01(\tR\tstorageId\x12\x1b\n" +
	"\tfile_path\x18\x02 \x01(\tR\bfilePath\x12 \n" +
	"\vprobability\x18\x03 \x01(\x02R\vprobability\x12\x16\n" +
	"\x06source\x18\x04 \x01(\tR\x06source\x12\x1d\n" +
	"\n" +
	"content_id\x18\x05 \x01(\tR\tcontentId\x123\n" +
	"\vsource_type\x18\x06 \x01(\x0e2\x12.monofs.SourceTypeR\n" +
	"sourceType\x12L\n" +
	"\rsource_config\x18\a \x03(\v2'.monofs.PredictedFile.SourceConfigEntryR\fsourceConfig\x1a?\n" +
	"\x11SourceConfigEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01*\x90\x01\n" +
	"\n" +
	"SourceType\x12\x17\n" +
	"\x13SOURCE_TYPE_UNKNOWN\x10\x00\x12\x13\n" +
	"\x0fSOURCE_TYPE_GIT\x10\x01\x12\x15\n" +
	"\x11SOURCE_TYPE_GOMOD\x10\x02\x12\x12\n" +
	"\x0eSOURCE_TYPE_S3\x10\x03\x12\x14\n" +
	"\x10SOURCE_TYPE_HTTP\x10\x04\x12\x13\n" +
	"\x0fSOURCE_TYPE_OCI\x10\x05*\x85\x01\n" +
	"\n" +
	"AccessType\x12\x17\n" +
	"\x13ACCESS_TYPE_UNKNOWN\x10\x00\x12\x14\n" +
	"\x10ACCESS_TYPE_READ\x10\x01\x12\x17\n" +
	"\x13ACCESS_TYPE_READDIR\x10\x02\x12\x16\n" +
	"\x12ACCESS_TYPE_LOOKUP\x10\x03\x12\x17\n" +
	"\x13ACCESS_TYPE_GETATTR\x10\x042\xec\x02\n" +
	"\vBlobFetcher\x12:\n" +
	"\tFetchBlob\x12\x18.monofs.FetchBlobRequest\x1a\x11.monofs.DataChunk0\x01\x12Q\n" +
	"\x0eFetchBlobBatch\x12\x1d.monofs.FetchBlobBatchRequest\x1a\x1e.monofs.FetchBlobBatchResponse0\x01\x12B\n" +
	"\rPrefetchBlobs\x12\x17.monofs.PrefetchRequest\x1a\x18.monofs.PrefetchResponse\x12C\n" +
	"\n" +
	"CheckCache\x12\x19.monofs.CheckCacheRequest\x1a\x1a.monofs.CheckCacheResponse\x12E\n" +
	"\bGetStats\x12\x1b.monofs.FetcherStatsRequest\x1a\x1c.monofs.FetcherStatsResponseB$Z\"github.com/radryc/monofs/api/protob\x06proto3"

var (
	file_api_proto_fetcher_proto_rawDescOnce sync.Once
	file_api_proto_fetcher_proto_rawDescData []byte
)

func file_api_proto_fetcher_proto_rawDescGZIP() []byte {
	file_api_proto_fetcher_proto_rawDescOnce.Do(func() {
		file_api_proto_fetcher_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_api_proto_fetcher_proto_rawDesc), len(file_api_proto_fetcher_proto_rawDesc)))
	})
	return file_api_proto_fetcher_proto_rawDescData
}

var file_api_proto_fetcher_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_api_proto_fetcher_proto_msgTypes = make([]protoimpl.MessageInfo, 21)
var file_api_proto_fetcher_proto_goTypes = []any{
	(SourceType)(0),                // 0: monofs.SourceType
	(AccessType)(0),                // 1: monofs.AccessType
	(*FetchBlobRequest)(nil),       // 2: monofs.FetchBlobRequest
	(*FetchBlobBatchRequest)(nil),  // 3: monofs.FetchBlobBatchRequest
	(*FetchBlobBatchResponse)(nil), // 4: monofs.FetchBlobBatchResponse
	(*PrefetchRequest)(nil),        // 5: monofs.PrefetchRequest
	(*PrefetchResponse)(nil),       // 6: monofs.PrefetchResponse
	(*CheckCacheRequest)(nil),      // 7: monofs.CheckCacheRequest
	(*CheckCacheResponse)(nil),     // 8: monofs.CheckCacheResponse
	(*FetcherStatsRequest)(nil),    // 9: monofs.FetcherStatsRequest
	(*FetcherStatsResponse)(nil),   // 10: monofs.FetcherStatsResponse
	(*SourceStats)(nil),            // 11: monofs.SourceStats
	(*AccessEvent)(nil),            // 12: monofs.AccessEvent
	(*ReportAccessRequest)(nil),    // 13: monofs.ReportAccessRequest
	(*ReportAccessResponse)(nil),   // 14: monofs.ReportAccessResponse
	(*GetPredictionsRequest)(nil),  // 15: monofs.GetPredictionsRequest
	(*GetPredictionsResponse)(nil), // 16: monofs.GetPredictionsResponse
	(*PredictedFile)(nil),          // 17: monofs.PredictedFile
	nil,                            // 18: monofs.FetchBlobRequest.SourceConfigEntry
	nil,                            // 19: monofs.CheckCacheResponse.CachedEntry
	nil,                            // 20: monofs.CheckCacheResponse.SizesEntry
	nil,                            // 21: monofs.FetcherStatsResponse.SourceStatsEntry
	nil,                            // 22: monofs.PredictedFile.SourceConfigEntry
	(*DataChunk)(nil),              // 23: monofs.DataChunk
}
var file_api_proto_fetcher_proto_depIdxs = []int32{
	0,  // 0: monofs.FetchBlobRequest.source_type:type_name -> monofs.SourceType
	18, // 1: monofs.FetchBlobRequest.source_config:type_name -> monofs.FetchBlobRequest.SourceConfigEntry
	2,  // 2: monofs.FetchBlobBatchRequest.blobs:type_name -> monofs.FetchBlobRequest
	2,  // 3: monofs.PrefetchRequest.blobs:type_name -> monofs.FetchBlobRequest
	0,  // 4: monofs.CheckCacheRequest.source_type:type_name -> monofs.SourceType
	19, // 5: monofs.CheckCacheResponse.cached:type_name -> monofs.CheckCacheResponse.CachedEntry
	20, // 6: monofs.CheckCacheResponse.sizes:type_name -> monofs.CheckCacheResponse.SizesEntry
	21, // 7: monofs.FetcherStatsResponse.source_stats:type_name -> monofs.FetcherStatsResponse.SourceStatsEntry
	1,  // 8: monofs.AccessEvent.access_type:type_name -> monofs.AccessType
	12, // 9: monofs.ReportAccessRequest.events:type_name -> monofs.AccessEvent
	17, // 10: monofs.GetPredictionsResponse.predictions:type_name -> monofs.PredictedFile
	0,  // 11: monofs.PredictedFile.source_type:type_name -> monofs.SourceType
	22, // 12: monofs.PredictedFile.source_config:type_name -> monofs.PredictedFile.SourceConfigEntry
	11, // 13: monofs.FetcherStatsResponse.SourceStatsEntry.value:type_name -> monofs.SourceStats
	2,  // 14: monofs.BlobFetcher.FetchBlob:input_type -> monofs.FetchBlobRequest
	3,  // 15: monofs.BlobFetcher.FetchBlobBatch:input_type -> monofs.FetchBlobBatchRequest
	5,  // 16: monofs.BlobFetcher.PrefetchBlobs:input_type -> monofs.PrefetchRequest
	7,  // 17: monofs.BlobFetcher.CheckCache:input_type -> monofs.CheckCacheRequest
	9,  // 18: monofs.BlobFetcher.GetStats:input_type -> monofs.FetcherStatsRequest
	23, // 19: monofs.BlobFetcher.FetchBlob:output_type -> monofs.DataChunk
	4,  // 20: monofs.BlobFetcher.FetchBlobBatch:output_type -> monofs.FetchBlobBatchResponse
	6,  // 21: monofs.BlobFetcher.PrefetchBlobs:output_type -> monofs.PrefetchResponse
	8,  // 22: monofs.BlobFetcher.CheckCache:output_type -> monofs.CheckCacheResponse
	10, // 23: monofs.BlobFetcher.GetStats:output_type -> monofs.FetcherStatsResponse
	19, // [19:24] is the sub-list for method output_type
	14, // [14:19] is the sub-list for method input_type
	14, // [14:14] is the sub-list for extension type_name
	14, // [14:14] is the sub-list for extension extendee
	0,  // [0:14] is the sub-list for field type_name
}

func init() { file_api_proto_fetcher_proto_init() }
func file_api_proto_fetcher_proto_init() {
	if File_api_proto_fetcher_proto != nil {
		return
	}
	file_api_proto_monofs_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_api_proto_fetcher_proto_rawDesc), len(file_api_proto_fetcher_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   21,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_api_proto_fetcher_proto_goTypes,
		DependencyIndexes: file_api_proto_fetcher_proto_depIdxs,
		EnumInfos:         file_api_proto_fetcher_proto_enumTypes,
		MessageInfos:      file_api_proto_fetcher_proto_msgTypes,
	}.Build()
	File_api_proto_fetcher_proto = out.File
	file_api_proto_fetcher_proto_goTypes = nil
	file_api_proto_fetcher_proto_depIdxs = nil
}
