// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.31.1
// source: api/proto/monofs.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MonoFSRouter_GetClusterInfo_FullMethodName           = "/monofs.MonoFSRouter/GetClusterInfo"
	MonoFSRouter_Heartbeat_FullMethodName                = "/monofs.MonoFSRouter/Heartbeat"
	MonoFSRouter_IngestRepository_FullMethodName         = "/monofs.MonoFSRouter/IngestRepository"
	MonoFSRouter_NotifyRepositoryIngested_FullMethodName = "/monofs.MonoFSRouter/NotifyRepositoryIngested"
	MonoFSRouter_DeleteRepository_FullMethodName         = "/monofs.MonoFSRouter/DeleteRepository"
	MonoFSRouter_GetNodeForFile_FullMethodName           = "/monofs.MonoFSRouter/GetNodeForFile"
	MonoFSRouter_RegisterClient_FullMethodName           = "/monofs.MonoFSRouter/RegisterClient"
	MonoFSRouter_UnregisterClient_FullMethodName         = "/monofs.MonoFSRouter/UnregisterClient"
	MonoFSRouter_ClientHeartbeat_FullMethodName          = "/monofs.MonoFSRouter/ClientHeartbeat"
	MonoFSRouter_ListClients_FullMethodName              = "/monofs.MonoFSRouter/ListClients"
	MonoFSRouter_RequestFailover_FullMethodName          = "/monofs.MonoFSRouter/RequestFailover"
	MonoFSRouter_GetNodeFiles_FullMethodName             = "/monofs.MonoFSRouter/GetNodeFiles"
	MonoFSRouter_GetClusterStats_FullMethodName          = "/monofs.MonoFSRouter/GetClusterStats"
	MonoFSRouter_GetNodeStats_FullMethodName             = "/monofs.MonoFSRouter/GetNodeStats"
	MonoFSRouter_DrainCluster_FullMethodName             = "/monofs.MonoFSRouter/DrainCluster"
	MonoFSRouter_UndrainCluster_FullMethodName           = "/monofs.MonoFSRouter/UndrainCluster"
)

// MonoFSRouterClient is the client API for MonoFSRouter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// MonoFSRouter is the coordinator service that provides cluster topology
type MonoFSRouterClient interface {
	// GetClusterInfo returns the list of backend nodes for sharding
	GetClusterInfo(ctx context.Context, in *ClusterInfoRequest, opts ...grpc.CallOption) (*ClusterInfoResponse, error)
	// Heartbeat for node health checking
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error)
	// IngestRepository triggers repository ingestion across the cluster (streaming progress)
	IngestRepository(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[IngestProgress], error)
	// NotifyRepositoryIngested is called by nodes when they complete repository ingestion
	NotifyRepositoryIngested(ctx context.Context, in *NotifyRepositoryIngestedRequest, opts ...grpc.CallOption) (*NotifyRepositoryIngestedResponse, error)
	// DeleteRepository removes a repository from all nodes (cleanup from memory and disk)
	DeleteRepository(ctx context.Context, in *DeleteRepositoryRequest, opts ...grpc.CallOption) (*DeleteRepositoryResponse, error)
	// GetNodeForFile returns the correct node for a file with fallback support (handles rebalancing)
	GetNodeForFile(ctx context.Context, in *GetNodeForFileRequest, opts ...grpc.CallOption) (*GetNodeForFileResponse, error)
	// Client lifecycle management
	RegisterClient(ctx context.Context, in *RegisterClientRequest, opts ...grpc.CallOption) (*RegisterClientResponse, error)
	UnregisterClient(ctx context.Context, in *UnregisterClientRequest, opts ...grpc.CallOption) (*UnregisterClientResponse, error)
	ClientHeartbeat(ctx context.Context, in *ClientHeartbeatRequest, opts ...grpc.CallOption) (*ClientHeartbeatResponse, error)
	ListClients(ctx context.Context, in *ListClientsRequest, opts ...grpc.CallOption) (*ListClientsResponse, error)
	// Graceful failover
	RequestFailover(ctx context.Context, in *FailoverRequest, opts ...grpc.CallOption) (*FailoverResponse, error)
	// Get files owned by a specific node (used for failover sync)
	GetNodeFiles(ctx context.Context, in *GetNodeFilesRequest, opts ...grpc.CallOption) (*GetNodeFilesResponse, error)
	// Statistics and monitoring
	GetClusterStats(ctx context.Context, in *ClusterStatsRequest, opts ...grpc.CallOption) (*ClusterStatsResponse, error)
	GetNodeStats(ctx context.Context, in *NodeStatsRequest, opts ...grpc.CallOption) (*NodeStatsResponse, error)
	// Cluster maintenance
	DrainCluster(ctx context.Context, in *DrainClusterRequest, opts ...grpc.CallOption) (*DrainClusterResponse, error)
	UndrainCluster(ctx context.Context, in *UndrainClusterRequest, opts ...grpc.CallOption) (*UndrainClusterResponse, error)
}

type monoFSRouterClient struct {
	cc grpc.ClientConnInterface
}

func NewMonoFSRouterClient(cc grpc.ClientConnInterface) MonoFSRouterClient {
	return &monoFSRouterClient{cc}
}

func (c *monoFSRouterClient) GetClusterInfo(ctx context.Context, in *ClusterInfoRequest, opts ...grpc.CallOption) (*ClusterInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterInfoResponse)
	err := c.cc.Invoke(ctx, MonoFSRouter_GetClusterInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSRouterClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, MonoFSRouter_Heartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSRouterClient) IngestRepository(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[IngestProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MonoFSRouter_ServiceDesc.Streams[0], MonoFSRouter_IngestRepository_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[IngestRequest, IngestProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonoFSRouter_IngestRepositoryClient = grpc.ServerStreamingClient[IngestProgress]

func (c *monoFSRouterClient) NotifyRepositoryIngested(ctx context.Context, in *NotifyRepositoryIngestedRequest, opts ...grpc.CallOption) (*NotifyRepositoryIngestedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NotifyRepositoryIngestedResponse)
	err := c.cc.Invoke(ctx, MonoFSRouter_NotifyRepositoryIngested_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSRouterClient) DeleteRepository(ctx context.Context, in *DeleteRepositoryRequest, opts ...grpc.CallOption) (*DeleteRepositoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteRepositoryResponse)
	err := c.cc.Invoke(ctx, MonoFSRouter_DeleteRepository_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSRouterClient) GetNodeForFile(ctx context.Context, in *GetNodeForFileRequest, opts ...grpc.CallOption) (*GetNodeForFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNodeForFileResponse)
	err := c.cc.Invoke(ctx, MonoFSRouter_GetNodeForFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSRouterClient) RegisterClient(ctx context.Context, in *RegisterClientRequest, opts ...grpc.CallOption) (*RegisterClientResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterClientResponse)
	err := c.cc.Invoke(ctx, MonoFSRouter_RegisterClient_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSRouterClient) UnregisterClient(ctx context.Context, in *UnregisterClientRequest, opts ...grpc.CallOption) (*UnregisterClientResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnregisterClientResponse)
	err := c.cc.Invoke(ctx, MonoFSRouter_UnregisterClient_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSRouterClient) ClientHeartbeat(ctx context.Context, in *ClientHeartbeatRequest, opts ...grpc.CallOption) (*ClientHeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClientHeartbeatResponse)
	err := c.cc.Invoke(ctx, MonoFSRouter_ClientHeartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSRouterClient) ListClients(ctx context.Context, in *ListClientsRequest, opts ...grpc.CallOption) (*ListClientsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListClientsResponse)
	err := c.cc.Invoke(ctx, MonoFSRouter_ListClients_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSRouterClient) RequestFailover(ctx context.Context, in *FailoverRequest, opts ...grpc.CallOption) (*FailoverResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FailoverResponse)
	err := c.cc.Invoke(ctx, MonoFSRouter_RequestFailover_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSRouterClient) GetNodeFiles(ctx context.Context, in *GetNodeFilesRequest, opts ...grpc.CallOption) (*GetNodeFilesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNodeFilesResponse)
	err := c.cc.Invoke(ctx, MonoFSRouter_GetNodeFiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSRouterClient) GetClusterStats(ctx context.Context, in *ClusterStatsRequest, opts ...grpc.CallOption) (*ClusterStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClusterStatsResponse)
	err := c.cc.Invoke(ctx, MonoFSRouter_GetClusterStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSRouterClient) GetNodeStats(ctx context.Context, in *NodeStatsRequest, opts ...grpc.CallOption) (*NodeStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeStatsResponse)
	err := c.cc.Invoke(ctx, MonoFSRouter_GetNodeStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSRouterClient) DrainCluster(ctx context.Context, in *DrainClusterRequest, opts ...grpc.CallOption) (*DrainClusterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DrainClusterResponse)
	err := c.cc.Invoke(ctx, MonoFSRouter_DrainCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSRouterClient) UndrainCluster(ctx context.Context, in *UndrainClusterRequest, opts ...grpc.CallOption) (*UndrainClusterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UndrainClusterResponse)
	err := c.cc.Invoke(ctx, MonoFSRouter_UndrainCluster_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MonoFSRouterServer is the server API for MonoFSRouter service.
// All implementations must embed UnimplementedMonoFSRouterServer
// for forward compatibility.
//
// MonoFSRouter is the coordinator service that provides cluster topology
type MonoFSRouterServer interface {
	// GetClusterInfo returns the list of backend nodes for sharding
	GetClusterInfo(context.Context, *ClusterInfoRequest) (*ClusterInfoResponse, error)
	// Heartbeat for node health checking
	Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
	// IngestRepository triggers repository ingestion across the cluster (streaming progress)
	IngestRepository(*IngestRequest, grpc.ServerStreamingServer[IngestProgress]) error
	// NotifyRepositoryIngested is called by nodes when they complete repository ingestion
	NotifyRepositoryIngested(context.Context, *NotifyRepositoryIngestedRequest) (*NotifyRepositoryIngestedResponse, error)
	// DeleteRepository removes a repository from all nodes (cleanup from memory and disk)
	DeleteRepository(context.Context, *DeleteRepositoryRequest) (*DeleteRepositoryResponse, error)
	// GetNodeForFile returns the correct node for a file with fallback support (handles rebalancing)
	GetNodeForFile(context.Context, *GetNodeForFileRequest) (*GetNodeForFileResponse, error)
	// Client lifecycle management
	RegisterClient(context.Context, *RegisterClientRequest) (*RegisterClientResponse, error)
	UnregisterClient(context.Context, *UnregisterClientRequest) (*UnregisterClientResponse, error)
	ClientHeartbeat(context.Context, *ClientHeartbeatRequest) (*ClientHeartbeatResponse, error)
	ListClients(context.Context, *ListClientsRequest) (*ListClientsResponse, error)
	// Graceful failover
	RequestFailover(context.Context, *FailoverRequest) (*FailoverResponse, error)
	// Get files owned by a specific node (used for failover sync)
	GetNodeFiles(context.Context, *GetNodeFilesRequest) (*GetNodeFilesResponse, error)
	// Statistics and monitoring
	GetClusterStats(context.Context, *ClusterStatsRequest) (*ClusterStatsResponse, error)
	GetNodeStats(context.Context, *NodeStatsRequest) (*NodeStatsResponse, error)
	// Cluster maintenance
	DrainCluster(context.Context, *DrainClusterRequest) (*DrainClusterResponse, error)
	UndrainCluster(context.Context, *UndrainClusterRequest) (*UndrainClusterResponse, error)
	mustEmbedUnimplementedMonoFSRouterServer()
}

// UnimplementedMonoFSRouterServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMonoFSRouterServer struct{}

func (UnimplementedMonoFSRouterServer) GetClusterInfo(context.Context, *ClusterInfoRequest) (*ClusterInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClusterInfo not implemented")
}
func (UnimplementedMonoFSRouterServer) Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedMonoFSRouterServer) IngestRepository(*IngestRequest, grpc.ServerStreamingServer[IngestProgress]) error {
	return status.Error(codes.Unimplemented, "method IngestRepository not implemented")
}
func (UnimplementedMonoFSRouterServer) NotifyRepositoryIngested(context.Context, *NotifyRepositoryIngestedRequest) (*NotifyRepositoryIngestedResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method NotifyRepositoryIngested not implemented")
}
func (UnimplementedMonoFSRouterServer) DeleteRepository(context.Context, *DeleteRepositoryRequest) (*DeleteRepositoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteRepository not implemented")
}
func (UnimplementedMonoFSRouterServer) GetNodeForFile(context.Context, *GetNodeForFileRequest) (*GetNodeForFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNodeForFile not implemented")
}
func (UnimplementedMonoFSRouterServer) RegisterClient(context.Context, *RegisterClientRequest) (*RegisterClientResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterClient not implemented")
}
func (UnimplementedMonoFSRouterServer) UnregisterClient(context.Context, *UnregisterClientRequest) (*UnregisterClientResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UnregisterClient not implemented")
}
func (UnimplementedMonoFSRouterServer) ClientHeartbeat(context.Context, *ClientHeartbeatRequest) (*ClientHeartbeatResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClientHeartbeat not implemented")
}
func (UnimplementedMonoFSRouterServer) ListClients(context.Context, *ListClientsRequest) (*ListClientsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListClients not implemented")
}
func (UnimplementedMonoFSRouterServer) RequestFailover(context.Context, *FailoverRequest) (*FailoverResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RequestFailover not implemented")
}
func (UnimplementedMonoFSRouterServer) GetNodeFiles(context.Context, *GetNodeFilesRequest) (*GetNodeFilesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNodeFiles not implemented")
}
func (UnimplementedMonoFSRouterServer) GetClusterStats(context.Context, *ClusterStatsRequest) (*ClusterStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetClusterStats not implemented")
}
func (UnimplementedMonoFSRouterServer) GetNodeStats(context.Context, *NodeStatsRequest) (*NodeStatsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNodeStats not implemented")
}
func (UnimplementedMonoFSRouterServer) DrainCluster(context.Context, *DrainClusterRequest) (*DrainClusterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DrainCluster not implemented")
}
func (UnimplementedMonoFSRouterServer) UndrainCluster(context.Context, *UndrainClusterRequest) (*UndrainClusterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UndrainCluster not implemented")
}
func (UnimplementedMonoFSRouterServer) mustEmbedUnimplementedMonoFSRouterServer() {}
func (UnimplementedMonoFSRouterServer) testEmbeddedByValue()                      {}

// UnsafeMonoFSRouterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MonoFSRouterServer will
// result in compilation errors.
type UnsafeMonoFSRouterServer interface {
	mustEmbedUnimplementedMonoFSRouterServer()
}

func RegisterMonoFSRouterServer(s grpc.ServiceRegistrar, srv MonoFSRouterServer) {
	// If the following call panics, it indicates UnimplementedMonoFSRouterServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MonoFSRouter_ServiceDesc, srv)
}

func _MonoFSRouter_GetClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSRouterServer).GetClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFSRouter_GetClusterInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSRouterServer).GetClusterInfo(ctx, req.(*ClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFSRouter_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSRouterServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFSRouter_Heartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSRouterServer).Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFSRouter_IngestRepository_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IngestRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MonoFSRouterServer).IngestRepository(m, &grpc.GenericServerStream[IngestRequest, IngestProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonoFSRouter_IngestRepositoryServer = grpc.ServerStreamingServer[IngestProgress]

func _MonoFSRouter_NotifyRepositoryIngested_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NotifyRepositoryIngestedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSRouterServer).NotifyRepositoryIngested(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFSRouter_NotifyRepositoryIngested_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSRouterServer).NotifyRepositoryIngested(ctx, req.(*NotifyRepositoryIngestedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFSRouter_DeleteRepository_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRepositoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSRouterServer).DeleteRepository(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFSRouter_DeleteRepository_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSRouterServer).DeleteRepository(ctx, req.(*DeleteRepositoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFSRouter_GetNodeForFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeForFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSRouterServer).GetNodeForFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFSRouter_GetNodeForFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSRouterServer).GetNodeForFile(ctx, req.(*GetNodeForFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFSRouter_RegisterClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSRouterServer).RegisterClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFSRouter_RegisterClient_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSRouterServer).RegisterClient(ctx, req.(*RegisterClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFSRouter_UnregisterClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSRouterServer).UnregisterClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFSRouter_UnregisterClient_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSRouterServer).UnregisterClient(ctx, req.(*UnregisterClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFSRouter_ClientHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClientHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSRouterServer).ClientHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFSRouter_ClientHeartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSRouterServer).ClientHeartbeat(ctx, req.(*ClientHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFSRouter_ListClients_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClientsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSRouterServer).ListClients(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFSRouter_ListClients_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSRouterServer).ListClients(ctx, req.(*ListClientsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFSRouter_RequestFailover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FailoverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSRouterServer).RequestFailover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFSRouter_RequestFailover_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSRouterServer).RequestFailover(ctx, req.(*FailoverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFSRouter_GetNodeFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeFilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSRouterServer).GetNodeFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFSRouter_GetNodeFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSRouterServer).GetNodeFiles(ctx, req.(*GetNodeFilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFSRouter_GetClusterStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClusterStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSRouterServer).GetClusterStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFSRouter_GetClusterStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSRouterServer).GetClusterStats(ctx, req.(*ClusterStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFSRouter_GetNodeStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSRouterServer).GetNodeStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFSRouter_GetNodeStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSRouterServer).GetNodeStats(ctx, req.(*NodeStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFSRouter_DrainCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DrainClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSRouterServer).DrainCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFSRouter_DrainCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSRouterServer).DrainCluster(ctx, req.(*DrainClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFSRouter_UndrainCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UndrainClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSRouterServer).UndrainCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFSRouter_UndrainCluster_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSRouterServer).UndrainCluster(ctx, req.(*UndrainClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MonoFSRouter_ServiceDesc is the grpc.ServiceDesc for MonoFSRouter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MonoFSRouter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "monofs.MonoFSRouter",
	HandlerType: (*MonoFSRouterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetClusterInfo",
			Handler:    _MonoFSRouter_GetClusterInfo_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _MonoFSRouter_Heartbeat_Handler,
		},
		{
			MethodName: "NotifyRepositoryIngested",
			Handler:    _MonoFSRouter_NotifyRepositoryIngested_Handler,
		},
		{
			MethodName: "DeleteRepository",
			Handler:    _MonoFSRouter_DeleteRepository_Handler,
		},
		{
			MethodName: "GetNodeForFile",
			Handler:    _MonoFSRouter_GetNodeForFile_Handler,
		},
		{
			MethodName: "RegisterClient",
			Handler:    _MonoFSRouter_RegisterClient_Handler,
		},
		{
			MethodName: "UnregisterClient",
			Handler:    _MonoFSRouter_UnregisterClient_Handler,
		},
		{
			MethodName: "ClientHeartbeat",
			Handler:    _MonoFSRouter_ClientHeartbeat_Handler,
		},
		{
			MethodName: "ListClients",
			Handler:    _MonoFSRouter_ListClients_Handler,
		},
		{
			MethodName: "RequestFailover",
			Handler:    _MonoFSRouter_RequestFailover_Handler,
		},
		{
			MethodName: "GetNodeFiles",
			Handler:    _MonoFSRouter_GetNodeFiles_Handler,
		},
		{
			MethodName: "GetClusterStats",
			Handler:    _MonoFSRouter_GetClusterStats_Handler,
		},
		{
			MethodName: "GetNodeStats",
			Handler:    _MonoFSRouter_GetNodeStats_Handler,
		},
		{
			MethodName: "DrainCluster",
			Handler:    _MonoFSRouter_DrainCluster_Handler,
		},
		{
			MethodName: "UndrainCluster",
			Handler:    _MonoFSRouter_UndrainCluster_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "IngestRepository",
			Handler:       _MonoFSRouter_IngestRepository_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/proto/monofs.proto",
}

const (
	MonoFS_Lookup_FullMethodName                  = "/monofs.MonoFS/Lookup"
	MonoFS_GetAttr_FullMethodName                 = "/monofs.MonoFS/GetAttr"
	MonoFS_ReadDir_FullMethodName                 = "/monofs.MonoFS/ReadDir"
	MonoFS_Read_FullMethodName                    = "/monofs.MonoFS/Read"
	MonoFS_Create_FullMethodName                  = "/monofs.MonoFS/Create"
	MonoFS_Write_FullMethodName                   = "/monofs.MonoFS/Write"
	MonoFS_Authenticate_FullMethodName            = "/monofs.MonoFS/Authenticate"
	MonoFS_GetNodeInfo_FullMethodName             = "/monofs.MonoFS/GetNodeInfo"
	MonoFS_IngestFile_FullMethodName              = "/monofs.MonoFS/IngestFile"
	MonoFS_IngestFileBatch_FullMethodName         = "/monofs.MonoFS/IngestFileBatch"
	MonoFS_IngestReplicaBatch_FullMethodName      = "/monofs.MonoFS/IngestReplicaBatch"
	MonoFS_RegisterRepository_FullMethodName      = "/monofs.MonoFS/RegisterRepository"
	MonoFS_GetRepositoryFiles_FullMethodName      = "/monofs.MonoFS/GetRepositoryFiles"
	MonoFS_SyncMetadataFromNode_FullMethodName    = "/monofs.MonoFS/SyncMetadataFromNode"
	MonoFS_ClearFailoverCache_FullMethodName      = "/monofs.MonoFS/ClearFailoverCache"
	MonoFS_ListRepositories_FullMethodName        = "/monofs.MonoFS/ListRepositories"
	MonoFS_GetRepositoryInfo_FullMethodName       = "/monofs.MonoFS/GetRepositoryInfo"
	MonoFS_GetOnboardingStatus_FullMethodName     = "/monofs.MonoFS/GetOnboardingStatus"
	MonoFS_MarkRepositoryOnboarded_FullMethodName = "/monofs.MonoFS/MarkRepositoryOnboarded"
	MonoFS_DeleteFile_FullMethodName              = "/monofs.MonoFS/DeleteFile"
	MonoFS_BuildDirectoryIndexes_FullMethodName   = "/monofs.MonoFS/BuildDirectoryIndexes"
)

// MonoFSClient is the client API for MonoFS service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// MonoFS is the backend node service for filesystem operations
type MonoFSClient interface {
	// Metadata operations (client caches these)
	Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupResponse, error)
	GetAttr(ctx context.Context, in *GetAttrRequest, opts ...grpc.CallOption) (*GetAttrResponse, error)
	ReadDir(ctx context.Context, in *ReadDirRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DirEntry], error)
	// Data operations
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DataChunk], error)
	// Write operations
	Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error)
	Write(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[WriteRequest, WriteResponse], error)
	// Authentication (stub for future mTLS)
	Authenticate(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	// Node identification
	GetNodeInfo(ctx context.Context, in *NodeInfoRequest, opts ...grpc.CallOption) (*NodeInfoResponse, error)
	// IngestFile stores file metadata (called by router during ingestion)
	IngestFile(ctx context.Context, in *IngestFileRequest, opts ...grpc.CallOption) (*IngestFileResponse, error)
	// IngestFileBatch stores multiple file metadata in a single transaction (optimized for bulk ingestion)
	IngestFileBatch(ctx context.Context, in *IngestFileBatchRequest, opts ...grpc.CallOption) (*IngestFileBatchResponse, error)
	// IngestReplicaBatch stores replica metadata for failover (backup copies, not primary owner)
	IngestReplicaBatch(ctx context.Context, in *IngestReplicaBatchRequest, opts ...grpc.CallOption) (*IngestReplicaBatchResponse, error)
	// RegisterRepository registers repository metadata on a node (called before file ingestion)
	RegisterRepository(ctx context.Context, in *RegisterRepositoryRequest, opts ...grpc.CallOption) (*RegisterRepositoryResponse, error)
	// Failover and replication RPCs
	GetRepositoryFiles(ctx context.Context, in *GetRepositoryFilesRequest, opts ...grpc.CallOption) (*GetRepositoryFilesResponse, error)
	SyncMetadataFromNode(ctx context.Context, in *SyncMetadataFromNodeRequest, opts ...grpc.CallOption) (*SyncMetadataFromNodeResponse, error)
	ClearFailoverCache(ctx context.Context, in *ClearFailoverCacheRequest, opts ...grpc.CallOption) (*ClearFailoverCacheResponse, error)
	// Repository discovery
	ListRepositories(ctx context.Context, in *ListRepositoriesRequest, opts ...grpc.CallOption) (*ListRepositoriesResponse, error)
	GetRepositoryInfo(ctx context.Context, in *GetRepositoryInfoRequest, opts ...grpc.CallOption) (*GetRepositoryInfoResponse, error)
	// Onboarding status tracking
	GetOnboardingStatus(ctx context.Context, in *OnboardingStatusRequest, opts ...grpc.CallOption) (*OnboardingStatusResponse, error)
	MarkRepositoryOnboarded(ctx context.Context, in *MarkRepositoryOnboardedRequest, opts ...grpc.CallOption) (*MarkRepositoryOnboardedResponse, error)
	// Cleanup operations (called by router after rebalancing)
	DeleteFile(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*DeleteFileResponse, error)
	// Build directory indexes in batch after ingestion (deferred for performance)
	BuildDirectoryIndexes(ctx context.Context, in *BuildDirectoryIndexesRequest, opts ...grpc.CallOption) (*BuildDirectoryIndexesResponse, error)
}

type monoFSClient struct {
	cc grpc.ClientConnInterface
}

func NewMonoFSClient(cc grpc.ClientConnInterface) MonoFSClient {
	return &monoFSClient{cc}
}

func (c *monoFSClient) Lookup(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LookupResponse)
	err := c.cc.Invoke(ctx, MonoFS_Lookup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSClient) GetAttr(ctx context.Context, in *GetAttrRequest, opts ...grpc.CallOption) (*GetAttrResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAttrResponse)
	err := c.cc.Invoke(ctx, MonoFS_GetAttr_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSClient) ReadDir(ctx context.Context, in *ReadDirRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DirEntry], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MonoFS_ServiceDesc.Streams[0], MonoFS_ReadDir_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ReadDirRequest, DirEntry]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonoFS_ReadDirClient = grpc.ServerStreamingClient[DirEntry]

func (c *monoFSClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DataChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MonoFS_ServiceDesc.Streams[1], MonoFS_Read_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ReadRequest, DataChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonoFS_ReadClient = grpc.ServerStreamingClient[DataChunk]

func (c *monoFSClient) Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateResponse)
	err := c.cc.Invoke(ctx, MonoFS_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSClient) Write(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[WriteRequest, WriteResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MonoFS_ServiceDesc.Streams[2], MonoFS_Write_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WriteRequest, WriteResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonoFS_WriteClient = grpc.ClientStreamingClient[WriteRequest, WriteResponse]

func (c *monoFSClient) Authenticate(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthResponse)
	err := c.cc.Invoke(ctx, MonoFS_Authenticate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSClient) GetNodeInfo(ctx context.Context, in *NodeInfoRequest, opts ...grpc.CallOption) (*NodeInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NodeInfoResponse)
	err := c.cc.Invoke(ctx, MonoFS_GetNodeInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSClient) IngestFile(ctx context.Context, in *IngestFileRequest, opts ...grpc.CallOption) (*IngestFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IngestFileResponse)
	err := c.cc.Invoke(ctx, MonoFS_IngestFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSClient) IngestFileBatch(ctx context.Context, in *IngestFileBatchRequest, opts ...grpc.CallOption) (*IngestFileBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IngestFileBatchResponse)
	err := c.cc.Invoke(ctx, MonoFS_IngestFileBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSClient) IngestReplicaBatch(ctx context.Context, in *IngestReplicaBatchRequest, opts ...grpc.CallOption) (*IngestReplicaBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IngestReplicaBatchResponse)
	err := c.cc.Invoke(ctx, MonoFS_IngestReplicaBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSClient) RegisterRepository(ctx context.Context, in *RegisterRepositoryRequest, opts ...grpc.CallOption) (*RegisterRepositoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterRepositoryResponse)
	err := c.cc.Invoke(ctx, MonoFS_RegisterRepository_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSClient) GetRepositoryFiles(ctx context.Context, in *GetRepositoryFilesRequest, opts ...grpc.CallOption) (*GetRepositoryFilesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRepositoryFilesResponse)
	err := c.cc.Invoke(ctx, MonoFS_GetRepositoryFiles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSClient) SyncMetadataFromNode(ctx context.Context, in *SyncMetadataFromNodeRequest, opts ...grpc.CallOption) (*SyncMetadataFromNodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncMetadataFromNodeResponse)
	err := c.cc.Invoke(ctx, MonoFS_SyncMetadataFromNode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSClient) ClearFailoverCache(ctx context.Context, in *ClearFailoverCacheRequest, opts ...grpc.CallOption) (*ClearFailoverCacheResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearFailoverCacheResponse)
	err := c.cc.Invoke(ctx, MonoFS_ClearFailoverCache_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSClient) ListRepositories(ctx context.Context, in *ListRepositoriesRequest, opts ...grpc.CallOption) (*ListRepositoriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListRepositoriesResponse)
	err := c.cc.Invoke(ctx, MonoFS_ListRepositories_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSClient) GetRepositoryInfo(ctx context.Context, in *GetRepositoryInfoRequest, opts ...grpc.CallOption) (*GetRepositoryInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRepositoryInfoResponse)
	err := c.cc.Invoke(ctx, MonoFS_GetRepositoryInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSClient) GetOnboardingStatus(ctx context.Context, in *OnboardingStatusRequest, opts ...grpc.CallOption) (*OnboardingStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnboardingStatusResponse)
	err := c.cc.Invoke(ctx, MonoFS_GetOnboardingStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSClient) MarkRepositoryOnboarded(ctx context.Context, in *MarkRepositoryOnboardedRequest, opts ...grpc.CallOption) (*MarkRepositoryOnboardedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MarkRepositoryOnboardedResponse)
	err := c.cc.Invoke(ctx, MonoFS_MarkRepositoryOnboarded_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSClient) DeleteFile(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*DeleteFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteFileResponse)
	err := c.cc.Invoke(ctx, MonoFS_DeleteFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *monoFSClient) BuildDirectoryIndexes(ctx context.Context, in *BuildDirectoryIndexesRequest, opts ...grpc.CallOption) (*BuildDirectoryIndexesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuildDirectoryIndexesResponse)
	err := c.cc.Invoke(ctx, MonoFS_BuildDirectoryIndexes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MonoFSServer is the server API for MonoFS service.
// All implementations must embed UnimplementedMonoFSServer
// for forward compatibility.
//
// MonoFS is the backend node service for filesystem operations
type MonoFSServer interface {
	// Metadata operations (client caches these)
	Lookup(context.Context, *LookupRequest) (*LookupResponse, error)
	GetAttr(context.Context, *GetAttrRequest) (*GetAttrResponse, error)
	ReadDir(*ReadDirRequest, grpc.ServerStreamingServer[DirEntry]) error
	// Data operations
	Read(*ReadRequest, grpc.ServerStreamingServer[DataChunk]) error
	// Write operations
	Create(context.Context, *CreateRequest) (*CreateResponse, error)
	Write(grpc.ClientStreamingServer[WriteRequest, WriteResponse]) error
	// Authentication (stub for future mTLS)
	Authenticate(context.Context, *AuthRequest) (*AuthResponse, error)
	// Node identification
	GetNodeInfo(context.Context, *NodeInfoRequest) (*NodeInfoResponse, error)
	// IngestFile stores file metadata (called by router during ingestion)
	IngestFile(context.Context, *IngestFileRequest) (*IngestFileResponse, error)
	// IngestFileBatch stores multiple file metadata in a single transaction (optimized for bulk ingestion)
	IngestFileBatch(context.Context, *IngestFileBatchRequest) (*IngestFileBatchResponse, error)
	// IngestReplicaBatch stores replica metadata for failover (backup copies, not primary owner)
	IngestReplicaBatch(context.Context, *IngestReplicaBatchRequest) (*IngestReplicaBatchResponse, error)
	// RegisterRepository registers repository metadata on a node (called before file ingestion)
	RegisterRepository(context.Context, *RegisterRepositoryRequest) (*RegisterRepositoryResponse, error)
	// Failover and replication RPCs
	GetRepositoryFiles(context.Context, *GetRepositoryFilesRequest) (*GetRepositoryFilesResponse, error)
	SyncMetadataFromNode(context.Context, *SyncMetadataFromNodeRequest) (*SyncMetadataFromNodeResponse, error)
	ClearFailoverCache(context.Context, *ClearFailoverCacheRequest) (*ClearFailoverCacheResponse, error)
	// Repository discovery
	ListRepositories(context.Context, *ListRepositoriesRequest) (*ListRepositoriesResponse, error)
	GetRepositoryInfo(context.Context, *GetRepositoryInfoRequest) (*GetRepositoryInfoResponse, error)
	// Onboarding status tracking
	GetOnboardingStatus(context.Context, *OnboardingStatusRequest) (*OnboardingStatusResponse, error)
	MarkRepositoryOnboarded(context.Context, *MarkRepositoryOnboardedRequest) (*MarkRepositoryOnboardedResponse, error)
	// Cleanup operations (called by router after rebalancing)
	DeleteFile(context.Context, *DeleteFileRequest) (*DeleteFileResponse, error)
	// Build directory indexes in batch after ingestion (deferred for performance)
	BuildDirectoryIndexes(context.Context, *BuildDirectoryIndexesRequest) (*BuildDirectoryIndexesResponse, error)
	mustEmbedUnimplementedMonoFSServer()
}

// UnimplementedMonoFSServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMonoFSServer struct{}

func (UnimplementedMonoFSServer) Lookup(context.Context, *LookupRequest) (*LookupResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Lookup not implemented")
}
func (UnimplementedMonoFSServer) GetAttr(context.Context, *GetAttrRequest) (*GetAttrResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAttr not implemented")
}
func (UnimplementedMonoFSServer) ReadDir(*ReadDirRequest, grpc.ServerStreamingServer[DirEntry]) error {
	return status.Error(codes.Unimplemented, "method ReadDir not implemented")
}
func (UnimplementedMonoFSServer) Read(*ReadRequest, grpc.ServerStreamingServer[DataChunk]) error {
	return status.Error(codes.Unimplemented, "method Read not implemented")
}
func (UnimplementedMonoFSServer) Create(context.Context, *CreateRequest) (*CreateResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedMonoFSServer) Write(grpc.ClientStreamingServer[WriteRequest, WriteResponse]) error {
	return status.Error(codes.Unimplemented, "method Write not implemented")
}
func (UnimplementedMonoFSServer) Authenticate(context.Context, *AuthRequest) (*AuthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Authenticate not implemented")
}
func (UnimplementedMonoFSServer) GetNodeInfo(context.Context, *NodeInfoRequest) (*NodeInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNodeInfo not implemented")
}
func (UnimplementedMonoFSServer) IngestFile(context.Context, *IngestFileRequest) (*IngestFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IngestFile not implemented")
}
func (UnimplementedMonoFSServer) IngestFileBatch(context.Context, *IngestFileBatchRequest) (*IngestFileBatchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IngestFileBatch not implemented")
}
func (UnimplementedMonoFSServer) IngestReplicaBatch(context.Context, *IngestReplicaBatchRequest) (*IngestReplicaBatchResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method IngestReplicaBatch not implemented")
}
func (UnimplementedMonoFSServer) RegisterRepository(context.Context, *RegisterRepositoryRequest) (*RegisterRepositoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterRepository not implemented")
}
func (UnimplementedMonoFSServer) GetRepositoryFiles(context.Context, *GetRepositoryFilesRequest) (*GetRepositoryFilesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRepositoryFiles not implemented")
}
func (UnimplementedMonoFSServer) SyncMetadataFromNode(context.Context, *SyncMetadataFromNodeRequest) (*SyncMetadataFromNodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SyncMetadataFromNode not implemented")
}
func (UnimplementedMonoFSServer) ClearFailoverCache(context.Context, *ClearFailoverCacheRequest) (*ClearFailoverCacheResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClearFailoverCache not implemented")
}
func (UnimplementedMonoFSServer) ListRepositories(context.Context, *ListRepositoriesRequest) (*ListRepositoriesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListRepositories not implemented")
}
func (UnimplementedMonoFSServer) GetRepositoryInfo(context.Context, *GetRepositoryInfoRequest) (*GetRepositoryInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetRepositoryInfo not implemented")
}
func (UnimplementedMonoFSServer) GetOnboardingStatus(context.Context, *OnboardingStatusRequest) (*OnboardingStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetOnboardingStatus not implemented")
}
func (UnimplementedMonoFSServer) MarkRepositoryOnboarded(context.Context, *MarkRepositoryOnboardedRequest) (*MarkRepositoryOnboardedResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MarkRepositoryOnboarded not implemented")
}
func (UnimplementedMonoFSServer) DeleteFile(context.Context, *DeleteFileRequest) (*DeleteFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteFile not implemented")
}
func (UnimplementedMonoFSServer) BuildDirectoryIndexes(context.Context, *BuildDirectoryIndexesRequest) (*BuildDirectoryIndexesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method BuildDirectoryIndexes not implemented")
}
func (UnimplementedMonoFSServer) mustEmbedUnimplementedMonoFSServer() {}
func (UnimplementedMonoFSServer) testEmbeddedByValue()                {}

// UnsafeMonoFSServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MonoFSServer will
// result in compilation errors.
type UnsafeMonoFSServer interface {
	mustEmbedUnimplementedMonoFSServer()
}

func RegisterMonoFSServer(s grpc.ServiceRegistrar, srv MonoFSServer) {
	// If the following call panics, it indicates UnimplementedMonoFSServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MonoFS_ServiceDesc, srv)
}

func _MonoFS_Lookup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).Lookup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_Lookup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).Lookup(ctx, req.(*LookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFS_GetAttr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAttrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).GetAttr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_GetAttr_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).GetAttr(ctx, req.(*GetAttrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFS_ReadDir_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadDirRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MonoFSServer).ReadDir(m, &grpc.GenericServerStream[ReadDirRequest, DirEntry]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonoFS_ReadDirServer = grpc.ServerStreamingServer[DirEntry]

func _MonoFS_Read_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MonoFSServer).Read(m, &grpc.GenericServerStream[ReadRequest, DataChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonoFS_ReadServer = grpc.ServerStreamingServer[DataChunk]

func _MonoFS_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).Create(ctx, req.(*CreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFS_Write_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MonoFSServer).Write(&grpc.GenericServerStream[WriteRequest, WriteResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MonoFS_WriteServer = grpc.ClientStreamingServer[WriteRequest, WriteResponse]

func _MonoFS_Authenticate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).Authenticate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_Authenticate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).Authenticate(ctx, req.(*AuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFS_GetNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).GetNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_GetNodeInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).GetNodeInfo(ctx, req.(*NodeInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFS_IngestFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).IngestFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_IngestFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).IngestFile(ctx, req.(*IngestFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFS_IngestFileBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestFileBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).IngestFileBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_IngestFileBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).IngestFileBatch(ctx, req.(*IngestFileBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFS_IngestReplicaBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestReplicaBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).IngestReplicaBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_IngestReplicaBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).IngestReplicaBatch(ctx, req.(*IngestReplicaBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFS_RegisterRepository_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRepositoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).RegisterRepository(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_RegisterRepository_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).RegisterRepository(ctx, req.(*RegisterRepositoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFS_GetRepositoryFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRepositoryFilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).GetRepositoryFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_GetRepositoryFiles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).GetRepositoryFiles(ctx, req.(*GetRepositoryFilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFS_SyncMetadataFromNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncMetadataFromNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).SyncMetadataFromNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_SyncMetadataFromNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).SyncMetadataFromNode(ctx, req.(*SyncMetadataFromNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFS_ClearFailoverCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearFailoverCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).ClearFailoverCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_ClearFailoverCache_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).ClearFailoverCache(ctx, req.(*ClearFailoverCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFS_ListRepositories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRepositoriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).ListRepositories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_ListRepositories_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).ListRepositories(ctx, req.(*ListRepositoriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFS_GetRepositoryInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRepositoryInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).GetRepositoryInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_GetRepositoryInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).GetRepositoryInfo(ctx, req.(*GetRepositoryInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFS_GetOnboardingStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnboardingStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).GetOnboardingStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_GetOnboardingStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).GetOnboardingStatus(ctx, req.(*OnboardingStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFS_MarkRepositoryOnboarded_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkRepositoryOnboardedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).MarkRepositoryOnboarded(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_MarkRepositoryOnboarded_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).MarkRepositoryOnboarded(ctx, req.(*MarkRepositoryOnboardedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFS_DeleteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).DeleteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_DeleteFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).DeleteFile(ctx, req.(*DeleteFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MonoFS_BuildDirectoryIndexes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildDirectoryIndexesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MonoFSServer).BuildDirectoryIndexes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MonoFS_BuildDirectoryIndexes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MonoFSServer).BuildDirectoryIndexes(ctx, req.(*BuildDirectoryIndexesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MonoFS_ServiceDesc is the grpc.ServiceDesc for MonoFS service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MonoFS_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "monofs.MonoFS",
	HandlerType: (*MonoFSServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Lookup",
			Handler:    _MonoFS_Lookup_Handler,
		},
		{
			MethodName: "GetAttr",
			Handler:    _MonoFS_GetAttr_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _MonoFS_Create_Handler,
		},
		{
			MethodName: "Authenticate",
			Handler:    _MonoFS_Authenticate_Handler,
		},
		{
			MethodName: "GetNodeInfo",
			Handler:    _MonoFS_GetNodeInfo_Handler,
		},
		{
			MethodName: "IngestFile",
			Handler:    _MonoFS_IngestFile_Handler,
		},
		{
			MethodName: "IngestFileBatch",
			Handler:    _MonoFS_IngestFileBatch_Handler,
		},
		{
			MethodName: "IngestReplicaBatch",
			Handler:    _MonoFS_IngestReplicaBatch_Handler,
		},
		{
			MethodName: "RegisterRepository",
			Handler:    _MonoFS_RegisterRepository_Handler,
		},
		{
			MethodName: "GetRepositoryFiles",
			Handler:    _MonoFS_GetRepositoryFiles_Handler,
		},
		{
			MethodName: "SyncMetadataFromNode",
			Handler:    _MonoFS_SyncMetadataFromNode_Handler,
		},
		{
			MethodName: "ClearFailoverCache",
			Handler:    _MonoFS_ClearFailoverCache_Handler,
		},
		{
			MethodName: "ListRepositories",
			Handler:    _MonoFS_ListRepositories_Handler,
		},
		{
			MethodName: "GetRepositoryInfo",
			Handler:    _MonoFS_GetRepositoryInfo_Handler,
		},
		{
			MethodName: "GetOnboardingStatus",
			Handler:    _MonoFS_GetOnboardingStatus_Handler,
		},
		{
			MethodName: "MarkRepositoryOnboarded",
			Handler:    _MonoFS_MarkRepositoryOnboarded_Handler,
		},
		{
			MethodName: "DeleteFile",
			Handler:    _MonoFS_DeleteFile_Handler,
		},
		{
			MethodName: "BuildDirectoryIndexes",
			Handler:    _MonoFS_BuildDirectoryIndexes_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReadDir",
			Handler:       _MonoFS_ReadDir_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Read",
			Handler:       _MonoFS_Read_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Write",
			Handler:       _MonoFS_Write_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "api/proto/monofs.proto",
}
